# 浮动

## 目录

[概念](#jump1)

[性质](#jump2)

[清除浮动](#jump3)

[添加一个元素清除浮动原理](#jump4)

[创建BFC清除浮动的原理](#jump5)

[](#jump)

---	

<span id="jump1"></span>

## 概念

### 为什么需要浮动

标准流不好控制横向间距

### 什么是浮动

将浮动框移到某一边的边缘，如果是两个框则会紧挨着

---

<span id="jump2"></span>

## 性质

### 对自己的影响

- 浮动的的元素会具有行内块元素的特性

- 形成"块"(BFC)，这个块会负责自己的布局，宽高由自己决定：比如 span 中用 float 这个 span 就形成了一个 BFC，就可以设置宽高了

### 对兄弟元素的影响

- 脱离文档流：浮动的盒子只会影响其后面的文档流，不会影响前面的

- 不脱离文本流：周围的文字依然认为浮动元素占有原来的位置

- 浮动的元素会一行内显示，位置尽量靠上，并靠左或右，如果一行装不下则会另起一行

### 对父级元素的影响

- 从布局上"消失"

- 高度塌陷

---

<span id="jump3"></span>

## 清除浮动

### 为什么要清除浮动

同时满足以下三个条件时就需要清除浮动：

1. 父级没有设置高度

2. 子盒子浮动了

3. 影响下面布局了

### 清除浮动的方法

#### 额外标签法

在浮动元素末尾添加一个空的块级标签如：```<div class="clear"></div>```，并在CSS样式中清除新添加的空标签的浮动：```.clear { clear: both; }```

优点：书写方便

缺点：添加许多无意义的标签，结构化较差，实际工作中用得很少

#### 给父级添加overflow属性

CSS中给父盒子添加overflow属性，并将其属性值设置为hidden, auto或scroll 

此方法必须定义 width 或 zoom:1，同时不能定义 height，使用 overflow:auto 时，浏览器会自动检查浮动区域的高度

原理：当给元素添加overflow: hidden后，元素成为一个BFC（(Block formatting context)）元素；
计算BFC的高度时，浮动元素也参与计算

优点：代码简洁

缺点：无法显示溢出的部分

#### after伪元素法

相当于额外标签法升级版，利用CSS而不是HTML给父盒子尾部添加伪元素

CSS中添加样式：

```css
.clearfix:after { /* 添加伪元素一般是用双冒号，这里用单冒号是为了照顾兼容性 */
  content: "";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}
.clearfix {
  /* 解决IE6、7兼容性问题 */
  *zoom: 1;
}
```
然后给父盒子添加一个clearfix类

优点：没有增加新标签，body结构更清晰

缺点：需要考虑浏览器兼容性

#### 双伪元素法

给父盒子前后都添加伪元素，代码比after伪元素法更为简洁

语法：

```css
.clearfix:before,
.clearfix:after {
  content: "";
  display: table;
}

.clearfix:after {
  clear: both;
}

.clearfix {
  *zoom: 1;
}
```

优点：代码更简洁

缺点：兼容性问题

### 方法分类

几种清除浮动的方法，归结起来其实是两大类：添加一个元素、创建BFC

---

<span id="jump4"></span>

## 添加一个元素清除浮动原理

额外标签法、伪元素法属于这一类

核心原理：在浮动元素左或右添加一个空元素（真实或伪元素），并给新增的元素添加```clear: both```

### clear的误区

css的clear属性并不是如字面上那样清除旁边的浮动，而是让添加了clear的元素自身不能和**前面的**浮动元素相邻

这里的**前面的**是相对的，例如左浮动时，**前面的**指的是设置了clear的元素的左边的元素

### 设置了clear后

例如，div1、div2均设置了左浮动，div2又设置了```clear:left```

由于div2的左边将不能与浮动元素相邻，因此div2只能跑到下一行

### 清除浮动的原理

在浮动元素左或右添加一个空元素并设置clear后，空元素会跑到下一行，这时父盒子的高度变为和浮动元素的高度一样

这样就好像浮动元素又能把父盒子撑开，高度塌陷消失了一样，因此起到了清楚浮动副作用的效果

但其实浮动元素本身并没有受到任何影响，更不用说被清除，起作用的是添加了clear的那个元素

另外，由于clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，因此借助伪元素清除浮动影响时需要设置display

---

<span id="jump5"></span>

## 创建BFC清除浮动的原理

给父级添加overflow法属于这里一类

### 原理

给父盒子添加overflow属性，并将其属性值设置为hidden, auto或scroll后，父盒子会生成一个BFC

而BFC具有“计算BFC的高度时，浮动元素也参与计算”这一性质

这样，原本由于浮动造成的高度塌陷而缺失的部分，就能参与到父盒子的高度计算中了
